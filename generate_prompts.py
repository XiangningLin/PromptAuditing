#!/usr/bin/env python3
"""
æç¤ºè¯ç”Ÿæˆå™¨ - ä»ç§å­æç¤ºè¯ç”Ÿæˆç»„åˆå’Œå˜ä½“
Prompt Generator - Generate combinations and variations from seed prompts
"""

import csv
import random
import json
from itertools import combinations
from datetime import datetime

def load_seed_prompts(filename='seed_prompts.csv'):
    """åŠ è½½ç§å­æç¤ºè¯"""
    prompts = {
        'good': [],
        'bad': []
    }
    
    with open(filename, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            prompts[row['label']].append(row)
    
    return prompts

def combine_bad_prompts(bad_prompts, num_combinations=50, max_violations=3):
    """
    ç»„åˆå¤šä¸ªåæç¤ºè¯ï¼Œåˆ›å»ºåŒ…å«å¤šç§è¿è§„çš„å¤æ‚æ¡ˆä¾‹
    """
    combined = []
    
    for _ in range(num_combinations):
        # éšæœºé€‰æ‹© 2-max_violations ä¸ªè¿è§„
        num_violations = random.randint(2, max_violations)
        selected = random.sample(bad_prompts, num_violations)
        
        # æå–æç¤ºè¯æ–‡æœ¬
        prompt_texts = [p['prompt'] for p in selected]
        
        # ç»„åˆæˆä¸€ä¸ªæç¤ºè¯
        combined_prompt = " ".join(prompt_texts)
        
        # è®°å½•è¿è§„çš„åˆ†ç±»
        categories = list(set([p['category'] for p in selected]))
        subcategories = [p['subcategory'] for p in selected]
        standard_ids = [p['standard_id'] for p in selected]
        
        combined.append({
            'type': 'combined_bad',
            'num_violations': num_violations,
            'categories': categories,
            'subcategories': subcategories,
            'standard_ids': standard_ids,
            'prompt': combined_prompt
        })
    
    return combined

def add_good_context_to_bad(bad_prompts, good_prompts, num_mixed=30):
    """
    åœ¨åæç¤ºè¯ä¸­æ·»åŠ å¥½çš„å…ƒç´ ï¼Œåˆ›å»ºæ··åˆæ¡ˆä¾‹
    """
    mixed = []
    
    for _ in range(num_mixed):
        bad = random.choice(bad_prompts)
        good = random.choice(good_prompts)
        
        # 50% æ¦‚ç‡ï¼šå¥½çš„å¼€å¤´ + åçš„å†…å®¹
        # 50% æ¦‚ç‡ï¼šåçš„å†…å®¹ + å¥½çš„ç»“å°¾
        if random.random() < 0.5:
            mixed_prompt = f"{good['prompt']} {bad['prompt']}"
            dominant = 'bad'
        else:
            mixed_prompt = f"{bad['prompt']} {good['prompt']}"
            dominant = 'bad'
        
        mixed.append({
            'type': 'mixed',
            'dominant': dominant,
            'bad_category': bad['category'],
            'bad_subcategory': bad['subcategory'],
            'bad_standard_id': bad['standard_id'],
            'good_category': good['category'],
            'prompt': mixed_prompt
        })
    
    return mixed

def create_subtle_violations(bad_prompts, num_subtle=20):
    """
    åˆ›å»ºå¾®å¦™çš„è¿è§„æ¡ˆä¾‹ï¼ˆæ›´éš¾æ£€æµ‹ï¼‰
    """
    subtle = []
    
    # è½¯åŒ–è¯­è¨€çš„æ¨¡æ¿
    softening_templates = [
        "You might want to consider {action}.",
        "It could be helpful to {action}.",
        "Some users find it useful to {action}.",
        "You may want to {action}.",
        "Consider {action} if appropriate.",
    ]
    
    for _ in range(num_subtle):
        bad = random.choice(bad_prompts)
        template = random.choice(softening_templates)
        
        # æå–æ ¸å¿ƒè¡ŒåŠ¨
        # ç®€åŒ–ç‰ˆæœ¬ï¼šç›´æ¥ä½¿ç”¨åŸæ–‡ä½†æ·»åŠ è½¯åŒ–å‰ç¼€
        subtle_prompt = f"{template.replace('{action}', 'follow this approach')} {bad['prompt']}"
        
        subtle.append({
            'type': 'subtle_violation',
            'original_category': bad['category'],
            'original_subcategory': bad['subcategory'],
            'original_standard_id': bad['standard_id'],
            'prompt': subtle_prompt
        })
    
    return subtle

def generate_category_specific_combinations(bad_prompts):
    """
    ç”Ÿæˆç‰¹å®šåˆ†ç±»å†…çš„ç»„åˆï¼ˆä¾‹å¦‚ï¼Œå¤šç§æ“çºµæ‰‹æ³•ï¼‰
    """
    category_combos = []
    
    # æŒ‰åˆ†ç±»åˆ†ç»„
    by_category = {}
    for p in bad_prompts:
        cat = p['category']
        if cat not in by_category:
            by_category[cat] = []
        by_category[cat].append(p)
    
    # ä¸ºæ¯ä¸ªåˆ†ç±»ç”Ÿæˆç»„åˆ
    for category, prompts in by_category.items():
        if len(prompts) >= 2:
            # ç”Ÿæˆ 2-3 ä¸ªåŒç±»è¿è§„çš„ç»„åˆ
            for _ in range(min(10, len(prompts) // 2)):
                num_combine = random.randint(2, min(3, len(prompts)))
                selected = random.sample(prompts, num_combine)
                
                combined_text = " ".join([p['prompt'] for p in selected])
                
                category_combos.append({
                    'type': 'category_specific',
                    'category': category,
                    'num_violations': num_combine,
                    'subcategories': [p['subcategory'] for p in selected],
                    'standard_ids': [p['standard_id'] for p in selected],
                    'prompt': combined_text
                })
    
    return category_combos

def save_generated_prompts(all_prompts, filename='generated_prompts.csv'):
    """ä¿å­˜ç”Ÿæˆçš„æç¤ºè¯åˆ° CSV"""
    with open(filename, 'w', encoding='utf-8', newline='') as f:
        fieldnames = ['id', 'type', 'expected_label', 'categories', 'details', 'prompt']
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        
        for idx, prompt_data in enumerate(all_prompts, 1):
            # ç¡®å®šé¢„æœŸæ ‡ç­¾
            if prompt_data['type'] in ['combined_bad', 'subtle_violation', 'category_specific']:
                expected_label = 'FAIL'
            elif prompt_data['type'] == 'mixed':
                expected_label = 'FAIL' if prompt_data.get('dominant') == 'bad' else 'UNCERTAIN'
            else:
                expected_label = 'UNKNOWN'
            
            # æå–åˆ†ç±»ä¿¡æ¯
            if 'categories' in prompt_data:
                categories = ', '.join(prompt_data['categories'])
            elif 'category' in prompt_data:
                categories = prompt_data['category']
            elif 'bad_category' in prompt_data:
                categories = prompt_data['bad_category']
            elif 'original_category' in prompt_data:
                categories = prompt_data['original_category']
            else:
                categories = ''
            
            # åˆ›å»ºè¯¦æƒ… JSON
            details = {k: v for k, v in prompt_data.items() if k not in ['prompt', 'type']}
            
            writer.writerow({
                'id': f'GEN_{idx:04d}',
                'type': prompt_data['type'],
                'expected_label': expected_label,
                'categories': categories,
                'details': json.dumps(details, ensure_ascii=False),
                'prompt': prompt_data['prompt']
            })
    
    print(f"âœ… å·²ä¿å­˜ {len(all_prompts)} ä¸ªç”Ÿæˆçš„æç¤ºè¯åˆ° {filename}")

def generate_statistics(all_prompts):
    """ç”Ÿæˆç»Ÿè®¡ä¿¡æ¯"""
    stats = {
        'total': len(all_prompts),
        'by_type': {},
        'by_expected_label': {}
    }
    
    for prompt in all_prompts:
        # æŒ‰ç±»å‹ç»Ÿè®¡
        ptype = prompt['type']
        stats['by_type'][ptype] = stats['by_type'].get(ptype, 0) + 1
    
    return stats

def main():
    print("="*80)
    print("æç¤ºè¯ç”Ÿæˆå™¨ / Prompt Generator")
    print("="*80)
    
    # åŠ è½½ç§å­æç¤ºè¯
    print("\nğŸ“‚ åŠ è½½ç§å­æç¤ºè¯...")
    seed_prompts = load_seed_prompts('seed_prompts.csv')
    print(f"   - å¥½çš„æç¤ºè¯: {len(seed_prompts['good'])} ä¸ª")
    print(f"   - åçš„æç¤ºè¯: {len(seed_prompts['bad'])} ä¸ª")
    
    # ç”Ÿæˆç»„åˆ
    print("\nğŸ”„ ç”Ÿæˆæç¤ºè¯ç»„åˆ...")
    
    print("   1. ç»„åˆå¤šä¸ªè¿è§„...")
    combined_bad = combine_bad_prompts(seed_prompts['bad'], num_combinations=50, max_violations=3)
    print(f"      âœ“ ç”Ÿæˆ {len(combined_bad)} ä¸ªç»„åˆè¿è§„æç¤ºè¯")
    
    print("   2. åˆ›å»ºæ··åˆæ¡ˆä¾‹...")
    mixed = add_good_context_to_bad(seed_prompts['bad'], seed_prompts['good'], num_mixed=30)
    print(f"      âœ“ ç”Ÿæˆ {len(mixed)} ä¸ªæ··åˆæç¤ºè¯")
    
    print("   3. åˆ›å»ºå¾®å¦™è¿è§„...")
    subtle = create_subtle_violations(seed_prompts['bad'], num_subtle=20)
    print(f"      âœ“ ç”Ÿæˆ {len(subtle)} ä¸ªå¾®å¦™è¿è§„æç¤ºè¯")
    
    print("   4. ç”Ÿæˆåˆ†ç±»ç‰¹å®šç»„åˆ...")
    category_specific = generate_category_specific_combinations(seed_prompts['bad'])
    print(f"      âœ“ ç”Ÿæˆ {len(category_specific)} ä¸ªåˆ†ç±»ç‰¹å®šç»„åˆ")
    
    # åˆå¹¶æ‰€æœ‰ç”Ÿæˆçš„æç¤ºè¯
    all_generated = combined_bad + mixed + subtle + category_specific
    
    # ä¿å­˜
    print("\nğŸ’¾ ä¿å­˜ç”Ÿæˆçš„æç¤ºè¯...")
    save_generated_prompts(all_generated, 'generated_prompts.csv')
    
    # ç»Ÿè®¡
    print("\nğŸ“Š ç”Ÿæˆç»Ÿè®¡:")
    stats = generate_statistics(all_generated)
    print(f"   æ€»è®¡: {stats['total']} ä¸ªæç¤ºè¯")
    print(f"\n   æŒ‰ç±»å‹åˆ†å¸ƒ:")
    for ptype, count in stats['by_type'].items():
        print(f"      - {ptype}: {count} ä¸ª")
    
    # ä¿å­˜ç»Ÿè®¡ä¿¡æ¯
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    stats_filename = f"generation_stats_{timestamp}.json"
    with open(stats_filename, 'w', encoding='utf-8') as f:
        json.dump(stats, f, indent=2, ensure_ascii=False)
    print(f"\n   ç»Ÿè®¡ä¿¡æ¯å·²ä¿å­˜åˆ°: {stats_filename}")
    
    print("\n" + "="*80)
    print("âœ… æç¤ºè¯ç”Ÿæˆå®Œæˆï¼")
    print("="*80)
    print(f"\nç”Ÿæˆçš„æ–‡ä»¶:")
    print(f"  - generated_prompts.csv ({stats['total']} ä¸ªæç¤ºè¯)")
    print(f"  - {stats_filename} (ç»Ÿè®¡ä¿¡æ¯)")
    print(f"\nè¿™äº›æç¤ºè¯å¯ä»¥ç”¨äº:")
    print(f"  1. è®­ç»ƒå’Œæµ‹è¯•å®¡è®¡æ¨¡å‹")
    print(f"  2. Benchmark ä¸åŒ AI æ¨¡å‹çš„æ£€æµ‹èƒ½åŠ›")
    print(f"  3. è¯„ä¼°å®¡è®¡ç³»ç»Ÿçš„é²æ£’æ€§")
    print(f"  4. ç”Ÿæˆæ›´å¤šè®­ç»ƒæ•°æ®")

if __name__ == "__main__":
    main()




